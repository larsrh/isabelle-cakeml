chapter \<open>Generated by Lem from \<open>semantics/typeSystem.lem\<close>.\<close>

theory "TypeSystem" 

imports
  Main
  "HOL-Library.Datatype_Records"
  "LEM.Lem_pervasives_extra"
  "Lib"
  "Namespace"
  "Ast"
  "SemanticPrimitives"

begin 

\<comment> \<open>\<open>
  Specification of CakeML's type system.
\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Lib\<close>\<close>
\<comment> \<open>\<open>open import Ast\<close>\<close>
\<comment> \<open>\<open>open import Namespace\<close>\<close>
\<comment> \<open>\<open>open import SemanticPrimitives\<close>\<close>


type_synonym type_ident =" nat "

\<comment> \<open>\<open> Types \<close>\<close>
datatype t =
  \<comment> \<open>\<open> Type variables that the user writes down ('a, 'b, etc.) \<close>\<close>
    Tvar " tvarN "
  \<comment> \<open>\<open> deBruijn indexed type variables. \<close>\<close>
  | Tvar_db " nat "
  \<comment> \<open>\<open> The two numbers represent the identity of the type constructor. The first
     is the identity of the compilation unit that it was defined in, and the
     second is its identity inside of that unit \<close>\<close>
  | Tapp " t list " " type_ident "

\<comment> \<open>\<open> Some abbreviations \<close>\<close>
definition Tarray_num  :: " nat "  where 
     " Tarray_num = (( 0 :: nat))"

definition Tbool_num  :: " nat "  where 
     " Tbool_num = (( 1 :: nat))"

definition Tchar_num  :: " nat "  where 
     " Tchar_num = (( 2 :: nat))"

definition Texn_num  :: " nat "  where 
     " Texn_num = (( 3 :: nat))"

definition Tfn_num  :: " nat "  where 
     " Tfn_num = (( 4 :: nat))"

definition Tint_num  :: " nat "  where 
     " Tint_num = (( 5 :: nat))"

definition Tlist_num  :: " nat "  where 
     " Tlist_num = (( 6 :: nat))"

definition Tref_num  :: " nat "  where 
     " Tref_num = (( 7 :: nat))"

definition Tstring_num  :: " nat "  where 
     " Tstring_num = (( 8 :: nat))"

definition Ttup_num  :: " nat "  where 
     " Ttup_num = (( 9 :: nat))"

definition Tvector_num  :: " nat "  where 
     " Tvector_num = (( 10 :: nat))"

definition Tword64_num  :: " nat "  where 
     " Tword64_num = (( 11 :: nat))"

definition Tword8_num  :: " nat "  where 
     " Tword8_num = (( 12 :: nat))"

definition Tword8array_num  :: " nat "  where 
     " Tword8array_num = (( 13 :: nat))"


\<comment> \<open>\<open> The numbers for the primitive types \<close>\<close>
definition prim_type_nums  :: "(nat)list "  where 
     " prim_type_nums = (
  [Tarray_num, Tchar_num, Texn_num, Tfn_num, Tint_num, Tref_num, Tstring_num, Ttup_num,
   Tvector_num, Tword64_num, Tword8_num, Tword8array_num])"


definition Tarray  :: " t \<Rightarrow> t "  where 
     " Tarray t1 = ( Tapp [t1] Tarray_num )" 
  for  t1  :: " t "

definition Tbool  :: " t "  where 
     " Tbool = ( Tapp [] Tbool_num )"

definition Tchar  :: " t "  where 
     " Tchar = ( Tapp [] Tchar_num )"

definition Texn  :: " t "  where 
     " Texn = ( Tapp [] Texn_num )"

definition Tfn  :: " t \<Rightarrow> t \<Rightarrow> t "  where 
     " Tfn t1 t2 = ( Tapp [t1,t2] Tfn_num )" 
  for  t1  :: " t " 
  and  t2  :: " t "

definition Tint  :: " t "  where 
     " Tint = ( Tapp [] Tint_num )"

definition Tlist  :: " t \<Rightarrow> t "  where 
     " Tlist t1 = ( Tapp [t1] Tlist_num )" 
  for  t1  :: " t "

definition Tref  :: " t \<Rightarrow> t "  where 
     " Tref t1 = ( Tapp [t1] Tref_num )" 
  for  t1  :: " t "

definition Tstring  :: " t "  where 
     " Tstring = ( Tapp [] Tstring_num )"

definition Ttup  :: "(t)list \<Rightarrow> t "  where 
     " Ttup ts = ( Tapp ts Ttup_num )" 
  for  ts  :: "(t)list "

definition Tvector  :: " t \<Rightarrow> t "  where 
     " Tvector t1 = ( Tapp [t1] Tvector_num )" 
  for  t1  :: " t "

definition Tword64  :: " t "  where 
     " Tword64 = ( Tapp [] Tword64_num )"

definition Tword8  :: " t "  where 
     " Tword8 = ( Tapp [] Tword8_num )"

definition Tword8array  :: " t "  where 
     " Tword8array = ( Tapp [] Tword8array_num )"


\<comment> \<open>\<open> Check that the free type variables are in the given list. Every deBruijn
 * variable must be smaller than the first argument. So if it is 0, no deBruijn
 * indices are permitted. \<close>\<close>
\<comment> \<open>\<open>val check_freevars : nat -> list tvarN -> t -> bool\<close>\<close>
function (sequential,domintros) 
check_freevars  :: " nat \<Rightarrow>(string)list \<Rightarrow> t \<Rightarrow> bool "  where 
     "
check_freevars dbmax tvs (Tvar tv) = (
  Set.member tv (set tvs))" 
  for  dbmax  :: " nat " 
  and  tvs  :: "(string)list " 
  and  tv  :: " string "
|"
check_freevars dbmax tvs (Tapp ts tn) = (
  ((\<forall> x \<in> (set ts).  (check_freevars dbmax tvs) x)))" 
  for  dbmax  :: " nat " 
  and  tvs  :: "(string)list " 
  and  tn  :: " nat " 
  and  ts  :: "(t)list "
|"
check_freevars dbmax tvs (Tvar_db n) = ( n < dbmax )" 
  for  dbmax  :: " nat " 
  and  tvs  :: "(string)list " 
  and  n  :: " nat " 
by pat_completeness auto


\<comment> \<open>\<open>val check_freevars_ast : list tvarN -> ast_t -> bool\<close>\<close>
function (sequential,domintros) 
check_freevars_ast  :: "(string)list \<Rightarrow> ast_t \<Rightarrow> bool "  where 
     "
check_freevars_ast tvs (Atvar tv) = (
  Set.member tv (set tvs))" 
  for  tvs  :: "(string)list " 
  and  tv  :: " string "
|"
check_freevars_ast tvs (Attup ts) = (
  ((\<forall> x \<in> (set ts).  (check_freevars_ast tvs) x)))" 
  for  tvs  :: "(string)list " 
  and  ts  :: "(ast_t)list "
|"
check_freevars_ast tvs (Atfun t1 t2) = (
  check_freevars_ast tvs t1 \<and> check_freevars_ast tvs t2 )" 
  for  tvs  :: "(string)list " 
  and  t1  :: " ast_t " 
  and  t2  :: " ast_t "
|"
check_freevars_ast tvs (Atapp ts tn) = (
  ((\<forall> x \<in> (set ts).  (check_freevars_ast tvs) x)))" 
  for  tvs  :: "(string)list " 
  and  tn  :: "((modN),(typeN))id0 " 
  and  ts  :: "(ast_t)list " 
by pat_completeness auto



\<comment> \<open>\<open> Simultaneous substitution of types for type variables in a type \<close>\<close>
\<comment> \<open>\<open>val type_subst : Map.map tvarN t -> t -> t\<close>\<close>
function (sequential,domintros) 
type_subst  :: "((string),(t))Map.map \<Rightarrow> t \<Rightarrow> t "  where 
     "
type_subst s (Tvar tv) = (
  (case   s tv of
      None => Tvar tv
    | Some(t1) => t1
  ))" 
  for  s  :: "((string),(t))Map.map " 
  and  tv  :: " string "
|"
type_subst s (Tapp ts tn) = (
  Tapp (List.map (type_subst s) ts) tn )" 
  for  s  :: "((string),(t))Map.map " 
  and  tn  :: " nat " 
  and  ts  :: "(t)list "
|"
type_subst s (Tvar_db n) = ( Tvar_db n )" 
  for  s  :: "((string),(t))Map.map " 
  and  n  :: " nat " 
by pat_completeness auto


\<comment> \<open>\<open> Increment the deBruijn indices in a type by n levels, skipping all levels
 * less than skip. \<close>\<close>
\<comment> \<open>\<open>val deBruijn_inc : nat -> nat -> t -> t\<close>\<close>
function (sequential,domintros) 
deBruijn_inc  :: " nat \<Rightarrow> nat \<Rightarrow> t \<Rightarrow> t "  where 
     "
deBruijn_inc skip n (Tvar tv) = ( Tvar tv )" 
  for  skip  :: " nat " 
  and  n  :: " nat " 
  and  tv  :: " string "
|"
deBruijn_inc skip n (Tvar_db m) = (
  if m < skip then
    Tvar_db m
  else
    Tvar_db (m + n))" 
  for  skip  :: " nat " 
  and  n  :: " nat " 
  and  m  :: " nat "
|"
deBruijn_inc skip n (Tapp ts tn) = ( Tapp (List.map (deBruijn_inc skip n) ts) tn )" 
  for  skip  :: " nat " 
  and  n  :: " nat " 
  and  tn  :: " nat " 
  and  ts  :: "(t)list " 
by pat_completeness auto


\<comment> \<open>\<open> skip the lowest given indices and replace the next (LENGTH ts) with the given types and reduce all the higher ones \<close>\<close>
\<comment> \<open>\<open>val deBruijn_subst : nat -> list t -> t -> t\<close>\<close>
function (sequential,domintros) 
deBruijn_subst  :: " nat \<Rightarrow>(t)list \<Rightarrow> t \<Rightarrow> t "  where 
     "
deBruijn_subst skip ts (Tvar tv) = ( Tvar tv )" 
  for  skip  :: " nat " 
  and  ts  :: "(t)list " 
  and  tv  :: " string "
|"
deBruijn_subst skip ts (Tvar_db n) = (
  if \<not> (n < skip) \<and> (n < (List.length ts + skip)) then
    List.nth ts (n - skip)
  else if \<not> (n < skip) then
    Tvar_db (n - List.length ts)
  else
    Tvar_db n )" 
  for  skip  :: " nat " 
  and  ts  :: "(t)list " 
  and  n  :: " nat "
|"
deBruijn_subst skip ts (Tapp ts' tn) = (
  Tapp (List.map (deBruijn_subst skip ts) ts') tn )" 
  for  skip  :: " nat " 
  and  ts  :: "(t)list " 
  and  tn  :: " nat " 
  and  ts'  :: "(t)list " 
by pat_completeness auto


\<comment> \<open>\<open> Type environments \<close>\<close>
datatype tenv_val_exp =
    Empty
  \<comment> \<open>\<open> Binds several de Bruijn type variables \<close>\<close>
  | Bind_tvar " nat " " tenv_val_exp "
  \<comment> \<open>\<open> The number is how many de Bruijn type variables the typescheme binds \<close>\<close>
  | Bind_name " varN " " nat " " t " " tenv_val_exp "

\<comment> \<open>\<open>val bind_tvar : nat -> tenv_val_exp -> tenv_val_exp\<close>\<close>
definition bind_tvar  :: " nat \<Rightarrow> tenv_val_exp \<Rightarrow> tenv_val_exp "  where 
     " bind_tvar tvs tenvE = ( if tvs =( 0 :: nat) then tenvE else Bind_tvar tvs tenvE )" 
  for  tvs  :: " nat " 
  and  tenvE  :: " tenv_val_exp "


\<comment> \<open>\<open>val opt_bind_name : maybe varN -> nat -> t -> tenv_val_exp -> tenv_val_exp\<close>\<close>
fun opt_bind_name  :: "(string)option \<Rightarrow> nat \<Rightarrow> t \<Rightarrow> tenv_val_exp \<Rightarrow> tenv_val_exp "  where 
     " opt_bind_name None tvs t1 tenvE = ( tenvE )" 
  for  tvs  :: " nat " 
  and  t1  :: " t " 
  and  tenvE  :: " tenv_val_exp "
|" opt_bind_name (Some n') tvs t1 tenvE = ( Bind_name n' tvs t1 tenvE )" 
  for  n'  :: " string " 
  and  tvs  :: " nat " 
  and  t1  :: " t " 
  and  tenvE  :: " tenv_val_exp "


\<comment> \<open>\<open>val tveLookup : varN -> nat -> tenv_val_exp -> maybe (nat * t)\<close>\<close>
fun 
tveLookup  :: " string \<Rightarrow> nat \<Rightarrow> tenv_val_exp \<Rightarrow>(nat*t)option "  where 
     "
tveLookup n inc Empty = ( None )" 
  for  n  :: " string " 
  and  inc  :: " nat "
|"
tveLookup n inc (Bind_tvar tvs tenvE) = ( tveLookup n (inc + tvs) tenvE )" 
  for  n  :: " string " 
  and  inc  :: " nat " 
  and  tenvE  :: " tenv_val_exp " 
  and  tvs  :: " nat "
|"
tveLookup n inc (Bind_name n' tvs t1 tenvE) = (
  if n' = n then
    Some (tvs, deBruijn_inc tvs inc t1)
  else
    tveLookup n inc tenvE )" 
  for  n  :: " string " 
  and  inc  :: " nat " 
  and  tenvE  :: " tenv_val_exp " 
  and  t1  :: " t " 
  and  tvs  :: " nat " 
  and  n'  :: " string "


type_synonym tenv_abbrev =" (modN, typeN, ( tvarN list * t)) namespace "
type_synonym tenv_ctor =" (modN, conN, ( tvarN list * t list * type_ident)) namespace "
type_synonym tenv_val =" (modN, varN, (nat * t)) namespace "

datatype_record type_env =
  
 v0 ::" tenv_val "
   
 c0 ::" tenv_ctor "
   
 t ::" tenv_abbrev "
   


\<comment> \<open>\<open>val extend_dec_tenv : type_env -> type_env -> type_env\<close>\<close>
definition extend_dec_tenv  :: " type_env \<Rightarrow> type_env \<Rightarrow> type_env "  where 
     " extend_dec_tenv tenv' tenv = (
  (| v0 = (nsAppend(v0   tenv')(v0   tenv)),
     c0 = (nsAppend(c0   tenv')(c0   tenv)),
     t = (nsAppend(t   tenv')(t   tenv)) |) )" 
  for  tenv'  :: " type_env " 
  and  tenv  :: " type_env "


\<comment> \<open>\<open>val lookup_varE : id modN varN -> tenv_val_exp -> maybe (nat * t)\<close>\<close>
fun lookup_varE  :: "((string),(string))id0 \<Rightarrow> tenv_val_exp \<Rightarrow>(nat*t)option "  where 
     " lookup_varE (Short x) tenvE = ( tveLookup x(( 0 :: nat)) tenvE )" 
  for  x  :: " string " 
  and  tenvE  :: " tenv_val_exp "
|" lookup_varE _ tenvE = ( None )" 
  for  tenvE  :: " tenv_val_exp "


\<comment> \<open>\<open>val lookup_var : id modN varN -> tenv_val_exp -> type_env -> maybe (nat * t)\<close>\<close>
definition lookup_var  :: "((modN),(varN))id0 \<Rightarrow> tenv_val_exp \<Rightarrow> type_env \<Rightarrow>(nat*t)option "  where 
     " lookup_var id1 tenvE tenv = (
  (case  lookup_varE id1 tenvE of
    Some x => Some x
  | None => nsLookup(v0   tenv) id1
  ))" 
  for  id1  :: "((modN),(varN))id0 " 
  and  tenvE  :: " tenv_val_exp " 
  and  tenv  :: " type_env "


\<comment> \<open>\<open>val num_tvs : tenv_val_exp -> nat\<close>\<close>
fun 
num_tvs  :: " tenv_val_exp \<Rightarrow> nat "  where 
     "
num_tvs Empty = (( 0 :: nat))"
|"
num_tvs (Bind_tvar tvs tenvE) = ( tvs + num_tvs tenvE )" 
  for  tenvE  :: " tenv_val_exp " 
  and  tvs  :: " nat "
|"
num_tvs (Bind_name n tvs t1 tenvE) = ( num_tvs tenvE )" 
  for  tenvE  :: " tenv_val_exp " 
  and  t1  :: " t " 
  and  tvs  :: " nat " 
  and  n  :: " string "


\<comment> \<open>\<open>val bind_var_list : nat -> list (varN * t) -> tenv_val_exp -> tenv_val_exp\<close>\<close>
fun 
bind_var_list  :: " nat \<Rightarrow>(string*t)list \<Rightarrow> tenv_val_exp \<Rightarrow> tenv_val_exp "  where 
     "
bind_var_list tvs [] tenvE = ( tenvE )" 
  for  tvs  :: " nat " 
  and  tenvE  :: " tenv_val_exp "
|"
bind_var_list tvs ((n,t1)# binds) tenvE = (
  Bind_name n tvs t1 (bind_var_list tvs binds tenvE))" 
  for  tvs  :: " nat " 
  and  binds  :: "(string*t)list " 
  and  t1  :: " t " 
  and  n  :: " string " 
  and  tenvE  :: " tenv_val_exp "


\<comment> \<open>\<open> A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders. The number is the maximum deBruijn type variable
 * allowed. \<close>\<close>
\<comment> \<open>\<open>val type_p : nat -> type_env -> pat -> t -> list (varN * t) -> bool\<close>\<close>

\<comment> \<open>\<open> An expression has a type \<close>\<close>
\<comment> \<open>\<open>val type_e : type_env -> tenv_val_exp -> exp -> t -> bool\<close>\<close>

\<comment> \<open>\<open> A list of expressions has a list of types \<close>\<close>
\<comment> \<open>\<open>val type_es : type_env -> tenv_val_exp -> list exp -> list t -> bool\<close>\<close>

\<comment> \<open>\<open> Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions \<close>\<close>
\<comment> \<open>\<open>val type_funs : type_env -> tenv_val_exp -> list (varN * varN * exp) -> list (varN * t) -> bool\<close>\<close>

\<comment> \<open>\<open> Check a declaration and update the top-level environments
 * The arguments are in order:
 * - whether to do extra checks
 * - the type environment
 * - the declaration
 * - the set of type identity stamps defined here
 * - the environment of new stuff declared here \<close>\<close>

\<comment> \<open>\<open>val type_d : bool -> type_env -> dec -> set nat -> type_env -> bool\<close>\<close>
\<comment> \<open>\<open>val type_ds : bool -> type_env -> list dec -> set nat -> type_env -> bool\<close>\<close>

\<comment> \<open>\<open> Check that the operator can have type (t1 -> ... -> tn -> t) \<close>\<close>
\<comment> \<open>\<open>val type_op : op -> list t -> t -> bool\<close>\<close>
definition type_op  :: " op0 \<Rightarrow>(t)list \<Rightarrow> t \<Rightarrow> bool "  where 
     " type_op op1 ts t1 = (
  (case  (op1,ts) of
      (Opapp, [t11, t2]) => t11 = Tfn t2 t1
    | (Opn _, [t11, t2]) => (t11 = Tint) \<and> ((t2 = Tint) \<and> (t1 = Tint))
    | (Opb _, [t11, t2]) => (t11 = Tint) \<and> ((t2 = Tint) \<and> (t1 = Tbool))
    | (Opw W8 _, [t11, t2]) => (t11 = Tword8) \<and> ((t2 = Tword8) \<and> (t1 = Tword8))
    | (Opw W64 _, [t11, t2]) => (t11 = Tword64) \<and> ((t2 = Tword64) \<and> (t1 = Tword64))
    | (FP_top _, [t11, t2, t3]) => (t11 = Tword64) \<and> ((t2 = Tword64) \<and> ((t3 = Tword64) \<and> (t1 = Tword64)))
    | (FP_bop _, [t11, t2]) => (t11 = Tword64) \<and> ((t2 = Tword64) \<and> (t1 = Tword64))
    | (FP_uop _, [t11]) =>  (t11 = Tword64) \<and> (t1 = Tword64)
    | (FP_cmp _, [t11, t2]) =>  (t11 = Tword64) \<and> ((t2 = Tword64) \<and> (t1 = Tbool))
    | (Shift W8 _ _, [t11]) => (t11 = Tword8) \<and> (t1 = Tword8)
    | (Shift W64 _ _, [t11]) => (t11 = Tword64) \<and> (t1 = Tword64)
    | (Equality, [t11, t2]) => (t11 = t2) \<and> (t1 = Tbool)
    | (Opassign, [t11, t2]) => (t11 = Tref t2) \<and> (t1 = Ttup [])
    | (Opref, [t11]) => t1 = Tref t11
    | (Opderef, [t11]) => t11 = Tref t1
    | (Aw8alloc, [t11, t2]) => (t11 = Tint) \<and> ((t2 = Tword8) \<and> (t1 = Tword8array))
    | (Aw8sub, [t11, t2]) => (t11 = Tword8array) \<and> ((t2 = Tint) \<and> (t1 = Tword8))
    | (Aw8length, [t11]) => (t11 = Tword8array) \<and> (t1 = Tint)
    | (Aw8update, [t11, t2, t3]) => (t11 = Tword8array) \<and> ((t2 = Tint) \<and> ((t3 = Tword8) \<and> (t1 = Ttup [])))
    | (WordFromInt W8, [t11]) => (t11 = Tint) \<and> (t1 = Tword8)
    | (WordToInt W8, [t11]) => (t11 = Tword8) \<and> (t1 = Tint)
    | (WordFromInt W64, [t11]) => (t11 = Tint) \<and> (t1 = Tword64)
    | (WordToInt W64, [t11]) => (t11 = Tword64) \<and> (t1 = Tint)
    | (CopyStrStr, [t11, t2, t3]) => (t11 = Tstring) \<and> ((t2 = Tint) \<and> ((t3 = Tint) \<and> (t1 = Tstring)))
    | (CopyStrAw8, [t11, t2, t3, t4, t5]) =>
      (t11 = Tstring) \<and> ((t2 = Tint) \<and> ((t3 = Tint) \<and> ((t4 = Tword8array) \<and> ((t5 = Tint) \<and> (t1 = Ttup [])))))
    | (CopyAw8Str, [t11, t2, t3]) => (t11 = Tword8array) \<and> ((t2 = Tint) \<and> ((t3 = Tint) \<and> (t1 = Tstring)))
    | (CopyAw8Aw8, [t11, t2, t3, t4, t5]) =>
      (t11 = Tword8array) \<and> ((t2 = Tint) \<and> ((t3 = Tint) \<and> ((t4 = Tword8array) \<and> ((t5 = Tint) \<and> (t1 = Ttup [])))))
    | (Chr, [t11]) => (t11 = Tint) \<and> (t1 = Tchar)
    | (Ord, [t11]) => (t11 = Tchar) \<and> (t1 = Tint)
    | (Chopb _, [t11, t2]) => (t11 = Tchar) \<and> ((t2 = Tchar) \<and> (t1 = Tbool))
    | (Implode, [t11]) => (t11 = Tlist Tchar) \<and> (t1 = Tstring)
    | (Explode, [t11]) => (t11 = Tstring) \<and> (t1 = Tlist Tchar)
    | (Strsub, [t11, t2]) => (t11 = Tstring) \<and> ((t2 = Tint) \<and> (t1 = Tchar))
    | (Strlen, [t11]) => (t11 = Tstring) \<and> (t1 = Tint)
    | (Strcat, [t11]) => (t11 = Tlist Tstring) \<and> (t1 = Tstring)
    | (VfromList, [Tapp [t11] ctor]) => (ctor = Tlist_num) \<and> (t1 = Tvector t11)
    | (Vsub, [t11, t2]) => (t2 = Tint) \<and> (Tvector t1 = t11)
    | (Vlength, [Tapp [t11] ctor]) => (ctor = Tvector_num) \<and> (t1 = Tint)
    | (Aalloc, [t11, t2]) => (t11 = Tint) \<and> (t1 = Tarray t2)
    | (AallocEmpty, [t11]) => (t11 = Ttup []) \<and> ((\<exists> t2.  t1 = Tarray t2))
    | (Asub, [t11, t2]) => (t2 = Tint) \<and> (Tarray t1 = t11)
    | (Alength, [Tapp [t11] ctor]) => (ctor = Tarray_num) \<and> (t1 = Tint)
    | (Aupdate, [t11, t2, t3]) => (t11 = Tarray t3) \<and> ((t2 = Tint) \<and> (t1 = Ttup []))
    | (ConfigGC, [t11,t2]) => (t11 = Tint) \<and> ((t2 = Tint) \<and> (t1 = Ttup []))
    | (FFI n, [t11,t2]) => (t11 = Tstring) \<and> ((t2 = Tword8array) \<and> (t1 = Ttup []))
    | (ListAppend, [Tapp [t11] ctor, t2]) => (ctor = Tlist_num) \<and> ((t2 = Tapp [t11] ctor) \<and> (t1 = t2))
    | _ => False
  ))" 
  for  op1  :: " op0 " 
  and  ts  :: "(t)list " 
  and  t1  :: " t "


\<comment> \<open>\<open>val check_type_names : tenv_abbrev -> ast_t -> bool\<close>\<close>
function (sequential,domintros) 
check_type_names  :: "((string),(string),((string)list*t))namespace \<Rightarrow> ast_t \<Rightarrow> bool "  where 
     "
check_type_names tenvT (Atvar tv) = (
  True )" 
  for  tenvT  :: "((string),(string),((string)list*t))namespace " 
  and  tv  :: " string "
|"
check_type_names tenvT (Attup ts) = (
  ((\<forall> x \<in> (set ts).  (check_type_names tenvT) x)))" 
  for  tenvT  :: "((string),(string),((string)list*t))namespace " 
  and  ts  :: "(ast_t)list "
|"
check_type_names tenvT (Atfun t1 t2) = (
  check_type_names tenvT t1 \<and> check_type_names tenvT t2 )" 
  for  tenvT  :: "((string),(string),((string)list*t))namespace " 
  and  t1  :: " ast_t " 
  and  t2  :: " ast_t "
|"
check_type_names tenvT (Atapp ts tn) = (
  (case  nsLookup tenvT tn of
    Some (tvs, _) => List.length tvs = List.length ts
  | None => False
  ) \<and>
  ((\<forall> x \<in> (set ts).  (check_type_names tenvT) x)))" 
  for  tenvT  :: "((string),(string),((string)list*t))namespace " 
  and  tn  :: "((modN),(typeN))id0 " 
  and  ts  :: "(ast_t)list " 
by pat_completeness auto


\<comment> \<open>\<open> Substitution of type names for the type they abbreviate \<close>\<close>
\<comment> \<open>\<open>val type_name_subst : tenv_abbrev -> ast_t -> t\<close>\<close>
function (sequential,domintros) 
type_name_subst  :: "((string),(string),((string)list*t))namespace \<Rightarrow> ast_t \<Rightarrow> t "  where 
     "
type_name_subst tenvT (Atvar tv) = ( Tvar tv )" 
  for  tenvT  :: "((string),(string),((string)list*t))namespace " 
  and  tv  :: " string "
|"
type_name_subst tenvT (Attup ts) = (
  Ttup (List.map (type_name_subst tenvT) ts))" 
  for  tenvT  :: "((string),(string),((string)list*t))namespace " 
  and  ts  :: "(ast_t)list "
|"
type_name_subst tenvT (Atfun t1 t2) = (
  Tfn (type_name_subst tenvT t1) (type_name_subst tenvT t2))" 
  for  tenvT  :: "((string),(string),((string)list*t))namespace " 
  and  t1  :: " ast_t " 
  and  t2  :: " ast_t "
|"
type_name_subst tenvT (Atapp ts tc) = (
  (let args = (List.map (type_name_subst tenvT) ts) in
  (case  nsLookup tenvT tc of
    Some (tvs, t1) => type_subst (map_of (Lem_list_extra.zipSameLength tvs args)) t1
  | None => Ttup args \<comment> \<open>\<open> can't happen, for a type that passes the check \<close>\<close>
  )))" 
  for  tenvT  :: "((string),(string),((string)list*t))namespace " 
  and  ts  :: "(ast_t)list " 
  and  tc  :: "((modN),(typeN))id0 " 
by pat_completeness auto


\<comment> \<open>\<open> Check that a type definition defines no already defined types or duplicate
 * constructors, and that the free type variables of each constructor argument
 * type are included in the type's type parameters. Also check that all of the
 * types mentioned are in scope. \<close>\<close>
\<comment> \<open>\<open>val check_ctor_tenv : tenv_abbrev -> list (list tvarN * typeN * list (conN * list ast_t)) -> bool\<close>\<close>
fun  check_ctor_tenv  :: "((modN),(typeN),((tvarN)list*t))namespace \<Rightarrow>((tvarN)list*string*(conN*(ast_t)list)list)list \<Rightarrow> bool "  where 
     " check_ctor_tenv tenvT [] = ( True )" 
  for  tenvT  :: "((modN),(typeN),((tvarN)list*t))namespace "
|" check_ctor_tenv tenvT ((tvs,tn,ctors)# tds) = (
  check_dup_ctors (tvs,tn,ctors) \<and>
  (Lem_list.allDistinct tvs \<and>
  (((\<forall> x \<in> (set ctors).  ( \<lambda>x .  
  (case  x of
      (cn,ts) => ((\<forall> x \<in> (set ts). (check_freevars_ast tvs) x))
                   \<and>
                   ((\<forall> x \<in> (set ts). (check_type_names tenvT) x))
  )) x)) \<and>
  (\<not> (Set.member tn (set (List.map ( \<lambda>x .  
  (case  x of (_,tn,_) => tn )) tds))) \<and>
  check_ctor_tenv tenvT tds))))" 
  for  tenvT  :: "((modN),(typeN),((tvarN)list*t))namespace " 
  and  ctors  :: "(conN*(ast_t)list)list " 
  and  tds  :: "((tvarN)list*string*(conN*(ast_t)list)list)list " 
  and  tn  :: " string " 
  and  tvs  :: "(tvarN)list "


\<comment> \<open>\<open>val build_ctor_tenv : tenv_abbrev -> list (list tvarN * typeN * list (conN * list ast_t)) -> list nat -> tenv_ctor\<close>\<close>
fun  build_ctor_tenv  :: "((modN),(typeN),((tvarN)list*t))namespace \<Rightarrow>((tvarN)list*string*(string*(ast_t)list)list)list \<Rightarrow>(nat)list \<Rightarrow>((string),(string),((tvarN)list*(t)list*nat))namespace "  where 
     " build_ctor_tenv tenvT [] [] = ( alist_to_ns [])" 
  for  tenvT  :: "((modN),(typeN),((tvarN)list*t))namespace "
|" build_ctor_tenv tenvT ((tvs,tn,ctors)# tds) (id1 # ids) = (
  nsAppend
    (build_ctor_tenv tenvT tds ids)
    (alist_to_ns
      (List.rev
        (List.map
          ( \<lambda>x .  
  (case  x of (cn,ts) => (cn,(tvs,List.map (type_name_subst tenvT) ts, id1)) ))
          ctors))))" 
  for  tenvT  :: "((modN),(typeN),((tvarN)list*t))namespace " 
  and  ctors  :: "(string*(ast_t)list)list " 
  and  tds  :: "((tvarN)list*string*(string*(ast_t)list)list)list " 
  and  tn  :: " string " 
  and  tvs  :: "(tvarN)list " 
  and  id1  :: " nat " 
  and  ids  :: "(nat)list "
|" build_ctor_tenv tenvT _ _ = ( alist_to_ns [])" 
  for  tenvT  :: "((modN),(typeN),((tvarN)list*t))namespace "


\<comment> \<open>\<open> For the value restriction on let-based polymorphism \<close>\<close>
\<comment> \<open>\<open>val is_value : exp -> bool\<close>\<close>
function (sequential,domintros) 
is_value  :: " exp0 \<Rightarrow> bool "  where 
     "
is_value (Lit _) = ( True )"
|"
is_value (Con _ es) = ( ((\<forall> x \<in> (set es).  is_value x)))" 
  for  es  :: "(exp0)list "
|"
is_value (Var _) = ( True )"
|"
is_value (Fun _ _) = ( True )"
|"
is_value (Tannot e _) = ( is_value e )" 
  for  e  :: " exp0 "
|"
is_value (Lannot e _) = ( is_value e )" 
  for  e  :: " exp0 "
|"
is_value _ = ( False )" 
by pat_completeness auto


inductive
type_ps  :: " nat \<Rightarrow> type_env \<Rightarrow>(pat)list \<Rightarrow>(t)list \<Rightarrow>(varN*t)list \<Rightarrow> bool "  
      and
type_p  :: " nat \<Rightarrow> type_env \<Rightarrow> pat \<Rightarrow> t \<Rightarrow>(varN*t)list \<Rightarrow> bool "  where

"pany" : " \<And> tvs tenv t0.
check_freevars tvs [] t0
==>
type_p tvs tenv Pany t0 []"

|

"pvar" : " \<And> tvs tenv n t0.
check_freevars tvs [] t0
==>
type_p tvs tenv (Pvar n) t0 [(n,t0)]"

|

"plit_int" : " \<And> tvs tenv n.

type_p tvs tenv (Plit (IntLit n)) Tint []"

|

"plit_char" : " \<And> tvs tenv c1.

type_p tvs tenv (Plit (Char c1)) Tchar []"

|

"plit_string" : " \<And> tvs tenv s.

type_p tvs tenv (Plit (StrLit s)) Tstring []"

|

"plit_word8" : " \<And> tvs tenv w.

type_p tvs tenv (Plit (Word8 w)) Tword8 []"

|

"plit_word64" : " \<And> tvs tenv w.

type_p tvs tenv (Plit (Word64 w)) Tword64 []"

|

"pcon_some" : " \<And> tvs tenv cn ps ts tvs' tn ts' bindings.
((\<forall> x \<in> (set ts').  (check_freevars tvs []) x)) \<and>
((List.length ts' = List.length tvs') \<and>
(type_ps tvs tenv ps (List.map (type_subst (map_of (Lem_list_extra.zipSameLength tvs' ts'))) ts) bindings \<and>
(nsLookup(c0   tenv) cn = Some (tvs', ts, tn))))
==>
type_p tvs tenv (Pcon (Some cn) ps) (Tapp ts' tn) bindings "

|

"pcon_none" : " \<And> tvs tenv ps ts bindings.
type_ps tvs tenv ps ts bindings
==>
type_p tvs tenv (Pcon None ps) (Ttup ts) bindings "

|

"pref" : " \<And> tvs tenv p t0 bindings.
type_p tvs tenv p t0 bindings
==>
type_p tvs tenv (Pref p) (Tref t0) bindings "

|

"ptypeannot" : " \<And> tvs tenv p t0 bindings.
check_freevars_ast [] t0 \<and>
(check_type_names(t   tenv) t0 \<and>
type_p tvs tenv p (type_name_subst(t   tenv) t0) bindings)
==>
type_p tvs tenv (Ptannot p t0) (type_name_subst(t   tenv) t0) bindings "

|

"empty" : " \<And> tvs tenv.

type_ps tvs tenv [] [] []"

|

"cons" : " \<And> tvs tenv p ps t0 ts bindings bindings'.
type_p tvs tenv p t0 bindings \<and>
type_ps tvs tenv ps ts bindings'
==>
type_ps tvs tenv (p # ps) (t0 # ts) (bindings'@bindings)"

inductive
type_funs  :: " type_env \<Rightarrow> tenv_val_exp \<Rightarrow>(varN*varN*exp0)list \<Rightarrow>(varN*t)list \<Rightarrow> bool "  
      and
type_es  :: " type_env \<Rightarrow> tenv_val_exp \<Rightarrow>(exp0)list \<Rightarrow>(t)list \<Rightarrow> bool "  
      and
type_e  :: " type_env \<Rightarrow> tenv_val_exp \<Rightarrow> exp0 \<Rightarrow> t \<Rightarrow> bool "  where

"lit_int" : " \<And> tenv tenvE n.

type_e tenv tenvE (Lit (IntLit n)) Tint "

|

"lit_char" : " \<And> tenv tenvE c1.

type_e tenv tenvE (Lit (Char c1)) Tchar "

|

"lit_string" : " \<And> tenv tenvE s.

type_e tenv tenvE (Lit (StrLit s)) Tstring "

|

"lit_word8" : " \<And> tenv tenvE w.

type_e tenv tenvE (Lit (Word8 w)) Tword8 "

|

"lit_word64" : " \<And> tenv tenvE w.

type_e tenv tenvE (Lit (Word64 w)) Tword64 "

|

"raise" : " \<And> tenv tenvE e t0.
check_freevars (num_tvs tenvE) [] t0 \<and>
type_e tenv tenvE e Texn
==>
type_e tenv tenvE (Raise e) t0 "


|

"handle" : " \<And> tenv tenvE e pes t0.
type_e tenv tenvE e t0 \<and> (\<not> (pes = []) \<and>
((\<forall> (p,e) \<in>  
  List.set pes. ( \<exists> bindings. 
   Lem_list.allDistinct (pat_bindings p []) \<and>
   (type_p (num_tvs tenvE) tenv p Texn bindings \<and>
   type_e tenv (bind_var_list(( 0 :: nat)) bindings tenvE) e t0)))))
==>
type_e tenv tenvE (Handle e pes) t0 "

|

"con_some" : " \<And> tenv tenvE cn es tvs tn ts' ts.
((\<forall> x \<in> (set ts').  (check_freevars (num_tvs tenvE) []) x)) \<and>
((List.length tvs = List.length ts') \<and>
(type_es tenv tenvE es (List.map (type_subst (map_of (Lem_list_extra.zipSameLength tvs ts'))) ts) \<and>
(nsLookup(c0   tenv) cn = Some (tvs, ts, tn))))
==>
type_e tenv tenvE (Con (Some cn) es) (Tapp ts' tn)"

|

"con_none" : " \<And> tenv tenvE es ts.
type_es tenv tenvE es ts
==>
type_e tenv tenvE (Con None es) (Ttup ts)"

|

"var" : " \<And> tenv tenvE n t0 targs tvs.
(tvs = List.length targs) \<and>
(((\<forall> x \<in> (set targs).  (check_freevars (num_tvs tenvE) []) x)) \<and>
(lookup_var n tenvE tenv = Some (tvs,t0)))
==>
type_e tenv tenvE (Var n) (deBruijn_subst(( 0 :: nat)) targs t0)"

|

"fn" : " \<And> tenv tenvE n e t1 t2.
check_freevars (num_tvs tenvE) [] t1 \<and>
type_e tenv (Bind_name n(( 0 :: nat)) t1 tenvE) e t2
==>
type_e tenv tenvE (Fun n e) (Tfn t1 t2)"

|

"app" : " \<And> tenv tenvE op0 es ts t0.
type_es tenv tenvE es ts \<and>
(type_op op0 ts t0 \<and>
check_freevars (num_tvs tenvE) [] t0)
==>
type_e tenv tenvE (App op0 es) t0 "

|

"log" : " \<And> tenv tenvE l e1 e2.
type_e tenv tenvE e1 Tbool \<and>
type_e tenv tenvE e2 Tbool
==>
type_e tenv tenvE (Log l e1 e2) Tbool "

|

"if'" : " \<And> tenv tenvE e1 e2 e3 t0.
type_e tenv tenvE e1 Tbool \<and>
(type_e tenv tenvE e2 t0 \<and>
type_e tenv tenvE e3 t0)
==>
type_e tenv tenvE (If e1 e2 e3) t0 "

|

"mat" : " \<And> tenv tenvE e pes t1 t2.
type_e tenv tenvE e t1 \<and> (\<not> (pes = []) \<and>
((\<forall> (p,e) \<in>  
  List.set pes.  ( \<exists> bindings. 
   Lem_list.allDistinct (pat_bindings p []) \<and>
   (type_p (num_tvs tenvE) tenv p t1 bindings \<and>
   type_e tenv (bind_var_list(( 0 :: nat)) bindings tenvE) e t2)))))
==>
type_e tenv tenvE (Mat e pes) t2 "

|

\<comment> \<open>\<open>
let_poly : forall tenv tenvE n e1 e2 t1 t2 tvs.
is_value e1 &&
type_e tenv (bind_tvar tvs tenvE) e1 t1 &&
type_e tenv (opt_bind_name n tvs t1 tenvE) e2 t2
==>
type_e tenv tenvE (Let n e1 e2) t2

and
\<close>\<close>

"let_mono" : " \<And> tenv tenvE n e1 e2 t1 t2.
type_e tenv tenvE e1 t1 \<and>
type_e tenv (opt_bind_name n(( 0 :: nat)) t1 tenvE) e2 t2
==>
type_e tenv tenvE (Let n e1 e2) t2 "

\<comment> \<open>\<open>
and

letrec : forall tenv tenvE funs e t tenv' tvs.
type_funs tenv (bind_var_list 0 tenv' (bind_tvar tvs tenvE)) funs tenv' &&
type_e tenv (bind_var_list tvs tenv' tenvE) e t
==>
type_e tenv tenvE (Letrec funs e) t
\<close>\<close>

|

"letrec" : " \<And> tenv tenvE funs e t0 bindings.
type_funs tenv (bind_var_list(( 0 :: nat)) bindings tenvE) funs bindings \<and>
type_e tenv (bind_var_list(( 0 :: nat)) bindings tenvE) e t0
==>
type_e tenv tenvE (Letrec funs e) t0 "

|

"typeannot": " \<And> tenv tenvE e t0.
check_freevars_ast [] t0 \<and>
(check_type_names(t   tenv) t0 \<and>
type_e tenv tenvE e (type_name_subst(t   tenv) t0))
==>
type_e tenv tenvE (Tannot e t0) (type_name_subst(t   tenv) t0)"

|

"locannot": " \<And> tenv tenvE e l t0.
type_e tenv tenvE e t0
==>
type_e tenv tenvE (Lannot e l) t0 "

|

"empty" : " \<And> tenv tenvE.

type_es tenv tenvE [] []"

|

"cons" : " \<And> tenv tenvE e es t0 ts.
type_e tenv tenvE e t0 \<and>
type_es tenv tenvE es ts
==>
type_es tenv tenvE (e # es) (t0 # ts)"

|

"no_funs" : " \<And> tenv tenvE.

type_funs tenv tenvE [] []"

|

"funs" : " \<And> tenv tenvE fn n e funs bindings t1 t2.
check_freevars (num_tvs tenvE) [] (Tfn t1 t2) \<and>
(type_e tenv (Bind_name n(( 0 :: nat)) t1 tenvE) e t2 \<and>
(type_funs tenv tenvE funs bindings \<and>
(Map.map_of bindings fn = None)))
==>
type_funs tenv tenvE ((fn, n, e)# funs) ((fn, Tfn t1 t2)# bindings)"

\<comment> \<open>\<open>val tenv_add_tvs : nat -> alist varN t -> alist varN (nat * t)\<close>\<close>
definition tenv_add_tvs  :: " nat \<Rightarrow>(string*t)list \<Rightarrow>(string*(nat*t))list "  where 
     " tenv_add_tvs tvs bindings = (
  List.map ( \<lambda>x .  
  (case  x of (n,t1) => (n,(tvs,t1)) )) bindings )" 
  for  tvs  :: " nat " 
  and  bindings  :: "(string*t)list "


\<comment> \<open>\<open>val type_pe_determ : type_env -> tenv_val_exp -> pat -> exp -> bool\<close>\<close>
definition type_pe_determ  :: " type_env \<Rightarrow> tenv_val_exp \<Rightarrow> pat \<Rightarrow> exp0 \<Rightarrow> bool "  where 
     " type_pe_determ tenv tenvE p e = ((
  \<forall> t1. 
  \<forall> tenv1. 
  \<forall> t2. 
  \<forall> tenv2. 
    (type_p(( 0 :: nat)) tenv p t1 tenv1 \<and> (type_e tenv tenvE e t1 \<and>
    (type_p(( 0 :: nat)) tenv p t2 tenv2 \<and> type_e tenv tenvE e t2)))
    \<longrightarrow>
    (tenv1 = tenv2)))" 
  for  tenv  :: " type_env " 
  and  tenvE  :: " tenv_val_exp " 
  and  p  :: " pat " 
  and  e  :: " exp0 "


\<comment> \<open>\<open>val tscheme_inst : (nat * t) -> (nat * t) -> bool\<close>\<close>
fun tscheme_inst  :: " nat*t \<Rightarrow> nat*t \<Rightarrow> bool "  where 
     " tscheme_inst (tvs_spec, t_spec) (tvs_impl, t_impl) = ((
  \<exists> subst. 
    (List.length subst = tvs_impl) \<and>
    (check_freevars tvs_impl [] t_impl \<and>
    (((\<forall> x \<in> (set subst).  (check_freevars tvs_spec []) x)) \<and>
    (deBruijn_subst(( 0 :: nat)) subst t_impl = t_spec)))))" 
  for  t_spec  :: " t " 
  and  tvs_spec  :: " nat " 
  and  t_impl  :: " t " 
  and  tvs_impl  :: " nat "


definition tenvLift  :: " string \<Rightarrow> type_env \<Rightarrow> type_env "  where 
     " tenvLift mn tenv = (
  (| v0 = (nsLift mn(v0   tenv)), c0 = (nsLift mn(c0   tenv)), t = (nsLift mn(t   tenv))  |) )" 
  for  mn  :: " string " 
  and  tenv  :: " type_env "


inductive
type_ds  :: " bool \<Rightarrow> type_env \<Rightarrow>(dec)list \<Rightarrow>(nat)set \<Rightarrow> type_env \<Rightarrow> bool "  
      and
type_d  :: " bool \<Rightarrow> type_env \<Rightarrow> dec \<Rightarrow>(nat)set \<Rightarrow> type_env \<Rightarrow> bool "  where

"dlet_poly" : " \<And> extra_checks tvs tenv p e t0 bindings locs.
is_value e \<and>
(Lem_list.allDistinct (pat_bindings p []) \<and>
(type_p tvs tenv p t0 bindings \<and>
(type_e tenv (bind_tvar tvs Empty) e t0 \<and>
(extra_checks \<longrightarrow>
  ((\<forall> tvs'. \<forall> bindings'. \<forall> t'. 
    (type_p tvs' tenv p t' bindings' \<and>
    type_e tenv (bind_tvar tvs' Empty) e t') \<longrightarrow>
      list_all2 tscheme_inst (List.map snd (tenv_add_tvs tvs' bindings')) (List.map snd (tenv_add_tvs tvs bindings))))))))
==>
type_d extra_checks tenv (Dlet locs p e)
  {}
  (| v0 = (alist_to_ns (tenv_add_tvs tvs bindings)), c0 = nsEmpty, t = nsEmpty |) "

|

"dlet_mono" : " \<And> extra_checks tenv p e t0 bindings locs.
\<comment> \<open>\<open> The following line makes sure that when the value restriction prohibits
   generalisation, a type error is given rather than picking an arbitrary
   instantiation. However, we should only do the check when the extra_checks
   argument tells us to. \<close>\<close>
(extra_checks \<longrightarrow> (\<not> (is_value e) \<and> type_pe_determ tenv Empty p e)) \<and>
(Lem_list.allDistinct (pat_bindings p []) \<and>
(type_p(( 0 :: nat)) tenv p t0 bindings \<and>
type_e tenv Empty e t0))
==>
type_d extra_checks tenv (Dlet locs p e)
  {} (| v0 = (alist_to_ns (tenv_add_tvs(( 0 :: nat)) bindings)), c0 = nsEmpty, t = nsEmpty |) "

|

"dletrec" : " \<And> extra_checks tenv funs bindings tvs locs.
type_funs tenv (bind_var_list(( 0 :: nat)) bindings (bind_tvar tvs Empty)) funs bindings \<and>
(extra_checks \<longrightarrow>
  ((\<forall> tvs'. \<forall> bindings'. 
    type_funs tenv (bind_var_list(( 0 :: nat)) bindings' (bind_tvar tvs' Empty)) funs bindings' \<longrightarrow>
      list_all2 tscheme_inst (List.map snd (tenv_add_tvs tvs' bindings')) (List.map snd (tenv_add_tvs tvs bindings)))))
==>
type_d extra_checks tenv (Dletrec locs funs)
  {} (| v0 = (alist_to_ns (tenv_add_tvs tvs bindings)), c0 = nsEmpty, t = nsEmpty |) "

|

"dtype" : " \<And> extra_checks tenv tdefs type_identities tenvT locs.
Lem_list.allDistinct type_identities \<and>
(disjnt (List.set type_identities)
         (List.set (Tlist_num # (Tbool_num # prim_type_nums))) \<and>
(check_ctor_tenv (nsAppend tenvT(t   tenv)) tdefs \<and>
((List.length type_identities = List.length tdefs) \<and>
(tenvT = alist_to_ns (map2
                      ( \<lambda>x .  
  (case  x of
      (tvs,tn,ctors) => \<lambda> i . 
                          (tn, (tvs, Tapp (List.map Tvar tvs) i))
  ))
                      tdefs type_identities)))))
==>
type_d extra_checks tenv (Dtype locs tdefs)
  (List.set type_identities)
  (| v0 = nsEmpty, c0 = (build_ctor_tenv (nsAppend tenvT(t   tenv)) tdefs type_identities), t = tenvT |) "

|

"dtabbrev" : " \<And> extra_checks tenv tvs tn t0 locs.
check_freevars_ast tvs t0 \<and>
(check_type_names(t   tenv) t0 \<and>
Lem_list.allDistinct tvs)
==>
type_d extra_checks tenv (Dtabbrev locs tvs tn t0)
  {}
  (| v0 = nsEmpty, c0 = nsEmpty, t = (nsSing tn (tvs,type_name_subst(t   tenv) t0)) |) "

|

"dexn" : " \<And> extra_checks tenv cn ts locs.
((\<forall> x \<in> (set ts).  (check_freevars_ast []) x)) \<and>
((\<forall> x \<in> (set ts).  (check_type_names(t   tenv)) x))
==>
type_d extra_checks tenv (Dexn locs cn ts)
  {}
  (| v0 = nsEmpty,
     c0 = (nsSing cn ([], List.map (type_name_subst(t   tenv)) ts, Texn_num)),
     t = nsEmpty |) "

|

"dmod" : " \<And> extra_checks tenv mn ds decls tenv'.
type_ds extra_checks tenv ds decls tenv'
==>
type_d extra_checks tenv (Dmod mn ds) decls (tenvLift mn tenv')"

|

"dlocal" : " \<And> extra_checks tenv lds ds tenv1 tenv2 decls1 decls2.
type_ds extra_checks tenv lds decls1 tenv1 \<and>
(type_ds extra_checks (extend_dec_tenv tenv1 tenv) ds decls2 tenv2 \<and>
disjnt decls1 decls2)
==>
type_d extra_checks tenv (Dlocal lds ds) (decls1 \<union> decls2) tenv2 "


|

"empty" : " \<And> extra_checks tenv.

type_ds extra_checks tenv []
  {}
  (| v0 = nsEmpty, c0 = nsEmpty, t = nsEmpty |) "

|

"cons" : " \<And> extra_checks tenv d ds tenv1 tenv2 decls1 decls2.
type_d extra_checks tenv d decls1 tenv1 \<and>
(type_ds extra_checks (extend_dec_tenv tenv1 tenv) ds decls2 tenv2 \<and>
disjnt decls1 decls2)
==>
type_ds extra_checks tenv (d # ds)
  (decls1 \<union> decls2) (extend_dec_tenv tenv2 tenv1)"

\<comment> \<open>\<open>
indreln [type_specs : list modN -> tenv_abbrev -> specs -> decls -> type_env -> bool]

empty : forall mn tenvT.
true
==>
type_specs mn tenvT []
  empty_decls <| v = nsEmpty; c = nsEmpty; t = nsEmpty |>

and

sval : forall mn tenvT x t specs tenv fvs decls subst.
check_freevars 0 fvs t &&
check_type_names tenvT t &&
type_specs mn tenvT specs decls tenv &&
subst = alistToFmap (List_extra.zipSameLength fvs (List.map Tvar_db (genlist (fun x -> x) (List.length fvs))))
==>
type_specs mn tenvT (Sval x t :: specs)
  decls
  (extend_dec_tenv tenv
    <| v = nsSing x (List.length fvs, type_subst subst (type_name_subst tenvT t));
       c = nsEmpty;
       t = nsEmpty |>)

and

stype : forall mn tenvT tenv td specs decls' decls tenvT'.
tenvT' = alist_to_ns (List.map (fun (tvs,tn,ctors) -> (tn, (tvs, Tapp (List.map Tvar tvs) (TC_name (mk_id mn tn))))) td) &&
check_ctor_tenv (nsAppend tenvT' tenvT) td &&
type_specs mn (nsAppend tenvT' tenvT) specs decls tenv &&
decls' = <| defined_mods = {};
            defined_types = Set.fromList (List.map (fun (tvs,tn,ctors) -> (mk_id mn tn)) td);
            defined_exns = {} |>
==>
type_specs mn tenvT (Stype td :: specs)
  (union_decls decls decls')
  (extend_dec_tenv tenv
   <| v = nsEmpty;
      c = build_ctor_tenv mn (nsAppend tenvT' tenvT) td;
      t = tenvT' |>)

and

stabbrev : forall mn tenvT tenvT' tvs tn t specs decls tenv.
List.allDistinct tvs &&
check_freevars 0 tvs t &&
check_type_names tenvT t &&
tenvT' = nsSing tn (tvs,type_name_subst tenvT t) &&
type_specs mn (nsAppend tenvT' tenvT) specs decls tenv
==>
type_specs mn tenvT (Stabbrev tvs tn t :: specs)
  decls (extend_dec_tenv tenv <| v = nsEmpty; c = nsEmpty; t = tenvT' |>)

and

sexn : forall mn tenvT tenv cn ts specs decls.
check_exn_tenv mn cn ts &&
type_specs mn tenvT specs decls tenv &&
List.all (check_type_names tenvT) ts
==>
type_specs mn tenvT (Sexn cn ts :: specs)
  (union_decls decls <| defined_mods = {}; defined_types = {}; defined_exns = {mk_id mn cn} |>)
  (extend_dec_tenv tenv
   <| v = nsEmpty;
      c = nsSing cn ([], List.map (type_name_subst tenvT) ts, TypeExn (mk_id mn cn));
      t = nsEmpty |>)

and

stype_opq : forall mn tenvT tenv tn specs tvs decls tenvT'.
List.allDistinct tvs &&
tenvT' = nsSing tn (tvs, Tapp (List.map Tvar tvs) (TC_name (mk_id mn tn))) &&
type_specs mn (nsAppend tenvT' tenvT) specs decls tenv
==>
type_specs mn tenvT (Stype_opq tvs tn :: specs)
  (union_decls decls <| defined_mods = {}; defined_types = {mk_id mn tn}; defined_exns = {} |>)
  (extend_dec_tenv tenv <| v = nsEmpty; c = nsEmpty; t = tenvT' |>)

val weak_decls : decls -> decls -> bool
let weak_decls decls_impl decls_spec =
  decls_impl.defined_mods = decls_spec.defined_mods &&
  decls_spec.defined_types subset decls_impl.defined_types &&
  decls_spec.defined_exns subset decls_impl.defined_exns
   \<close>\<close>

\<comment> \<open>\<open>
val weak_tenvT : id modN typeN -> (list tvarN * t) -> (list tvarN * t) -> bool
let weak_tenvT n (tvs_spec, t_spec) (tvs_impl, t_impl) =
  \<open> For simplicity, we reject matches that differ only by renaming of bound type variables \<close>
  tvs_spec = tvs_impl &&
  (t_spec = t_impl ||
   \<open> The specified type is opaque \<close>
   t_spec = Tapp (List.map Tvar tvs_spec) (TC_name n))
   \<close>\<close>

definition tscheme_inst2  :: " 'a \<Rightarrow> nat*t \<Rightarrow> nat*t \<Rightarrow> bool "  where 
     " tscheme_inst2 _ ts1 ts2 = ( tscheme_inst ts1 ts2 )" 
  for  ts1  :: " nat*t " 
  and  ts2  :: " nat*t "


\<comment> \<open>\<open>val weak_tenv : type_env -> type_env -> bool\<close>\<close>
definition weak_tenv  :: " type_env \<Rightarrow> type_env \<Rightarrow> bool "  where 
     " weak_tenv tenv_impl tenv_spec = (
  nsSub tscheme_inst2(v0   tenv_spec)(v0   tenv_impl) \<and>
  nsSub ( \<lambda>x .  
  (case  x of _ => \<lambda> x y .  x = y ))(c0   tenv_spec)(c0   tenv_impl))" 
  for  tenv_impl  :: " type_env " 
  and  tenv_spec  :: " type_env "
\<comment> \<open>\<open> &&
  nsSub weak_tenvT tenv_spec.t tenv_impl.t\<close>\<close>

\<comment> \<open>\<open>
indreln [check_signature : list modN -> tenv_abbrev -> decls -> type_env -> maybe specs -> decls -> type_env -> bool]

none : forall mn tenvT decls tenv.
true
==>
check_signature mn tenvT decls tenv Nothing decls tenv

and

some : forall mn specs tenv_impl tenv_spec decls_impl decls_spec tenvT.
weak_tenv tenv_impl tenv_spec &&
weak_decls decls_impl decls_spec &&
type_specs mn tenvT specs decls_spec tenv_spec
==>
check_signature mn tenvT decls_impl tenv_impl (Just specs) decls_spec tenv_spec

let tenvLift mn tenv =
  <| v = nsLift mn tenv.v; c = nsLift mn tenv.c; t = nsLift mn tenv.t; |>

indreln [type_top : bool -> decls -> type_env -> top -> decls -> type_env -> bool]

tdec : forall extra_checks tenv d tenv' decls decls'.
type_d extra_checks [] decls tenv d decls' tenv'
==>
type_top extra_checks decls tenv (Tdec d) decls' tenv'

and

tmod : forall extra_checks tenv mn spec ds tenv_impl tenv_spec decls decls_impl decls_spec.
not ([mn] IN decls.defined_mods) &&
type_ds extra_checks [mn] decls tenv ds decls_impl tenv_impl &&
check_signature [mn] tenv.t decls_impl tenv_impl spec decls_spec tenv_spec
==>
type_top extra_checks decls tenv (Tmod mn spec ds)
  (union_decls <| defined_mods = {[mn]}; defined_types = {}; defined_exns = {} |> decls_spec)
  (tenvLift mn tenv_spec)

indreln [type_prog : bool -> decls -> type_env -> list top -> decls -> type_env -> bool]

empty : forall extra_checks tenv decls.
true
==>
type_prog extra_checks decls tenv [] empty_decls <| v = nsEmpty; c = nsEmpty; t = nsEmpty |>

and

cons : forall extra_checks tenv top tops tenv1 tenv2 decls decls1 decls2.
type_top extra_checks decls tenv top decls1 tenv1 &&
type_prog extra_checks (union_decls decls1 decls) (extend_dec_tenv tenv1 tenv) tops decls2 tenv2
==>
type_prog extra_checks decls tenv (top :: tops)
  (union_decls decls2 decls1) (extend_dec_tenv tenv2 tenv1)
  \<close>\<close>
end
