chapter \<open>Generated by Lem from \<open>semantics/alt_semantics/bigStep.lem\<close>.\<close>

theory "BigStep" 

imports
  Main
  "HOL-Library.Datatype_Records"
  "LEM.Lem_pervasives_extra"
  "Lib"
  "Namespace"
  "Ast"
  "SemanticPrimitives"
  "Ffi"
  "SmallStep"

begin 

\<comment> \<open>\<open>
  A clocked relational big-step semantics for CakeML. This semantics
  is no longer used in the CakeML development.
\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Lib\<close>\<close>
\<comment> \<open>\<open>open import Namespace\<close>\<close>
\<comment> \<open>\<open>open import Ast\<close>\<close>
\<comment> \<open>\<open>open import SemanticPrimitives\<close>\<close>
\<comment> \<open>\<open>open import Ffi\<close>\<close>

\<comment> \<open>\<open> To get the definition of expression divergence to use in defining definition
 * divergence \<close>\<close>
\<comment> \<open>\<open>open import SmallStep\<close>\<close>

\<comment> \<open>\<open> ------------------------ Big step semantics -------------------------- \<close>\<close>

\<comment> \<open>\<open> If the first argument is true, the big step semantics counts down how many
   functions applications have happened, and raises an exception when the counter
   runs out. \<close>\<close>

inductive
evaluate_match  :: " bool \<Rightarrow>(v)sem_env \<Rightarrow> 'ffi state \<Rightarrow> v \<Rightarrow>(pat*exp0)list \<Rightarrow> v \<Rightarrow> 'ffi state*((v),(v))result \<Rightarrow> bool "  
      and
evaluate_list  :: " bool \<Rightarrow>(v)sem_env \<Rightarrow> 'ffi state \<Rightarrow>(exp0)list \<Rightarrow> 'ffi state*(((v)list),(v))result \<Rightarrow> bool "  
      and
evaluate  :: " bool \<Rightarrow>(v)sem_env \<Rightarrow> 'ffi state \<Rightarrow> exp0 \<Rightarrow> 'ffi state*((v),(v))result \<Rightarrow> bool "  where

"lit" : " \<And> ck env l s.

evaluate ck env s (Lit l) (s, Rval (Litv l))"

|

"raise1" : " \<And> ck env e s1 s2 v1.
evaluate ck s1 env e (s2, Rval v1)
==>
evaluate ck s1 env (Raise e) (s2, Rerr (Rraise v1))"

|

"raise2" : " \<And> ck env e s1 s2 err.
evaluate ck s1 env e (s2, Rerr err)
==>
evaluate ck s1 env (Raise e) (s2, Rerr err)"

|

"handle1" : " \<And> ck s1 s2 env e v1 pes.
evaluate ck s1 env e (s2, Rval v1)
==>
evaluate ck s1 env (Handle e pes) (s2, Rval v1)"

|

"handle2" : " \<And> ck s1 s2 env e pes v1 bv.
evaluate ck env s1 e (s2, Rerr (Rraise v1)) \<and>
evaluate_match ck env s2 v1 pes v1 bv
==>
evaluate ck env s1 (Handle e pes) bv "

|

"handle3" : " \<And> ck s1 s2 env e pes a.
evaluate ck env s1 e (s2, Rerr (Rabort a))
==>
evaluate ck env s1 (Handle e pes) (s2, Rerr (Rabort a))"

|

"con1" : " \<And> ck env cn es vs s s' v1.
do_con_check(c   env) cn (List.length es) \<and>
((build_conv(c   env) cn (List.rev vs) = Some v1) \<and>
evaluate_list ck env s (List.rev es) (s', Rval vs))
==>
evaluate ck env s (Con cn es) (s', Rval v1)"

|

"con2" : " \<And> ck env cn es s.
\<not> (do_con_check(c   env) cn (List.length es))
==>
evaluate ck env s (Con cn es) (s, Rerr (Rabort Rtype_error))"

|

"con3" : " \<And> ck env cn es err s s'.
do_con_check(c   env) cn (List.length es) \<and>
evaluate_list ck env s (List.rev es) (s', Rerr err)
==>
evaluate ck env s (Con cn es) (s', Rerr err)"

|

"var1" : " \<And> ck env n v1 s.
nsLookup(v   env) n = Some v1
==>
evaluate ck env s (Var n) (s, Rval v1)"

|

"var2" : " \<And> ck env n s.
nsLookup(v   env) n = None
==>
evaluate ck env s (Var n) (s, Rerr (Rabort Rtype_error))"

|

"fn" : " \<And> ck env n e s.

evaluate ck env s (Fun n e) (s, Rval (Closure env n e))"

|

"app1" : " \<And> ck env es vs env' e bv s1 s2.
evaluate_list ck env s1 (List.rev es) (s2, Rval vs) \<and>
((do_opapp (List.rev vs) = Some (env', e)) \<and>
((ck \<longrightarrow> \<not> ((clock   s2) =(( 0 :: nat)))) \<and>
evaluate ck env' (if ck then ( s2 (| clock := ((clock   s2) -( 1 :: nat)) |)) else s2) e bv))
==>
evaluate ck env s1 (App Opapp es) bv "

|

"app2" : " \<And> ck env es vs env' e s1 s2.
evaluate_list ck env s1 (List.rev es) (s2, Rval vs) \<and>
((do_opapp (List.rev vs) = Some (env', e)) \<and>
(((clock   s2) =( 0 :: nat)) \<and>
ck))
==>
evaluate ck env s1 (App Opapp es) (s2, Rerr (Rabort Rtimeout_error))"

|

"app3" : " \<And> ck env es vs s1 s2.
evaluate_list ck env s1 (List.rev es) (s2, Rval vs) \<and>
(do_opapp (List.rev vs) = None)
==>
evaluate ck env s1 (App Opapp es) (s2, Rerr (Rabort Rtype_error))"

|

"app4" : " \<And> ck env op0 es vs res s1 s2 refs' ffi'.
evaluate_list ck env s1 (List.rev es) (s2, Rval vs) \<and>
((do_app ((refs   s2),(ffi   s2)) op0 (List.rev vs) = Some ((refs',ffi'), res)) \<and>
(op0 \<noteq> Opapp))
==>
evaluate ck env s1 (App op0 es) (( s2 (| refs := refs', ffi :=ffi' |)), res)"

|

"app5" : " \<And> ck env op0 es vs s1 s2.
evaluate_list ck env s1 (List.rev es) (s2, Rval vs) \<and>
((do_app ((refs   s2),(ffi   s2)) op0 (List.rev vs) = None) \<and>
(op0 \<noteq> Opapp))
==>
evaluate ck env s1 (App op0 es) (s2, Rerr (Rabort Rtype_error))"

|

"app6" : " \<And> ck env op0 es err s1 s2.
evaluate_list ck env s1 (List.rev es) (s2, Rerr err)
==>
evaluate ck env s1 (App op0 es) (s2, Rerr err)"

|

"log1" : " \<And> ck env op0 e1 e2 v1 e' bv s1 s2.
evaluate ck env s1 e1 (s2, Rval v1) \<and>
((do_log op0 v1 e2 = Some (Exp e')) \<and>
evaluate ck env s2 e' bv)
==>
evaluate ck env s1 (Log op0 e1 e2) bv "

|

"log2" : " \<And> ck env op0 e1 e2 v1 bv s1 s2.
evaluate ck env s1 e1 (s2, Rval v1) \<and>
(do_log op0 v1 e2 = Some (Val bv))
==>
evaluate ck env s1 (Log op0 e1 e2) (s2, Rval bv)"

|

"log3" : " \<And> ck env op0 e1 e2 v1 s1 s2.
evaluate ck env s1 e1 (s2, Rval v1) \<and>
(do_log op0 v1 e2 = None)
==>
evaluate ck env s1 (Log op0 e1 e2) (s2, Rerr (Rabort Rtype_error))"

|

"log4" : " \<And> ck env op0 e1 e2 err s s'.
evaluate ck env s e1 (s', Rerr err)
==>
evaluate ck env s (Log op0 e1 e2) (s', Rerr err)"

|

"if1" : " \<And> ck env e1 e2 e3 v1 e' bv s1 s2.
evaluate ck env s1 e1 (s2, Rval v1) \<and>
((do_if v1 e2 e3 = Some e') \<and>
evaluate ck env s2 e' bv)
==>
evaluate ck env s1 (If e1 e2 e3) bv "

|

"if2" : " \<And> ck env e1 e2 e3 v1 s1 s2.
evaluate ck env s1 e1 (s2, Rval v1) \<and>
(do_if v1 e2 e3 = None)
==>
evaluate ck env s1 (If e1 e2 e3) (s2, Rerr (Rabort Rtype_error))"

|

"if3" : " \<And> ck env e1 e2 e3 err s s'.
evaluate ck env s e1 (s', Rerr err)
==>
evaluate ck env s (If e1 e2 e3) (s', Rerr err)"

|

"mat1" : " \<And> ck env e pes v1 bv s1 s2.
evaluate ck env s1 e (s2, Rval v1) \<and>
evaluate_match ck env s2 v1 pes bind_exn_v bv
==>
evaluate ck env s1 (Mat e pes) bv "

|

"mat2" : " \<And> ck env e pes err s s'.
evaluate ck env s e (s', Rerr err)
==>
evaluate ck env s (Mat e pes) (s', Rerr err)"

|

"let1" : " \<And> ck env n e1 e2 v1 bv s1 s2.
evaluate ck env s1 e1 (s2, Rval v1) \<and>
evaluate ck ( env (| v := (nsOptBind n v1(v   env)) |)) s2 e2 bv
==>
evaluate ck env s1 (Let n e1 e2) bv "

|

"let2" : " \<And> ck env n e1 e2 err s s'.
evaluate ck env s e1 (s', Rerr err)
==>
evaluate ck env s (Let n e1 e2) (s', Rerr err)"

|

"letrec1" : " \<And> ck env funs e bv s.
Lem_list.allDistinct (List.map ( \<lambda>x .  
  (case  x of (x,y,z) => x )) funs) \<and>
evaluate ck ( env (| v := (build_rec_env funs env(v   env)) |)) s e bv
==>
evaluate ck env s (Letrec funs e) bv "

|

"letrec2" : " \<And> ck env funs e s.
\<not> (Lem_list.allDistinct (List.map ( \<lambda>x .  
  (case  x of (x,y,z) => x )) funs))
==>
evaluate ck env s (Letrec funs e) (s, Rerr (Rabort Rtype_error))"

|

"tannot" : " \<And> ck env e t0 s bv.
evaluate ck env s e bv
==>
evaluate ck env s (Tannot e t0) bv "

|

"locannot" : " \<And> ck env e l s bv.
evaluate ck env s e bv
==>
evaluate ck env s (Lannot e l) bv "

|

"empty" : " \<And> ck env s.

evaluate_list ck env s [] (s, Rval [])"

|

"cons1" : " \<And> ck env e es v1 vs s1 s2 s3.
evaluate ck env s1 e (s2, Rval v1) \<and>
evaluate_list ck env s2 es (s3, Rval vs)
==>
evaluate_list ck env s1 (e # es) (s3, Rval (v1 # vs))"

|

"cons2" : " \<And> ck env e es err s s'.
evaluate ck env s e (s', Rerr err)
==>
evaluate_list ck env s (e # es) (s', Rerr err)"

|

"cons3" : " \<And> ck env e es v1 err s1 s2 s3.
evaluate ck env s1 e (s2, Rval v1) \<and>
evaluate_list ck env s2 es (s3, Rerr err)
==>
evaluate_list ck env s1 (e # es) (s3, Rerr err)"

|

"mat_empty" : " \<And> ck env v1 err_v s.

evaluate_match ck env s v1 [] err_v (s, Rerr (Rraise err_v))"

|

"mat_cons1" : " \<And> ck env env' v1 p pes e bv err_v s.
Lem_list.allDistinct (pat_bindings p []) \<and>
((pmatch(c   env)(refs   s) p v1 [] = Match env') \<and>
evaluate ck ( env (| v := (nsAppend (alist_to_ns env')(v   env)) |)) s e bv)
==>
evaluate_match ck env s v1 ((p,e)# pes) err_v bv "

|

"mat_cons2" : " \<And> ck env v1 p e pes bv s err_v.
Lem_list.allDistinct (pat_bindings p []) \<and>
((pmatch(c   env)(refs   s) p v1 [] = No_match) \<and>
evaluate_match ck env s v1 pes err_v bv)
==>
evaluate_match ck env s v1 ((p,e)# pes) err_v bv "

|

"mat_cons3" : " \<And> ck env v1 p e pes s err_v.
pmatch(c   env)(refs   s) p v1 [] = Match_type_error
==>
evaluate_match ck env s v1 ((p,e)# pes) err_v (s, Rerr (Rabort Rtype_error))"

|

"mat_cons4" : " \<And> ck env v1 p e pes s err_v.
\<not> (Lem_list.allDistinct (pat_bindings p []))
==>
evaluate_match ck env s v1 ((p,e)# pes) err_v (s, Rerr (Rabort Rtype_error))"

\<comment> \<open>\<open> The set tid_or_exn part of the state tracks all of the types and exceptions
 * that have been declared \<close>\<close>
inductive
evaluate_decs  :: " bool \<Rightarrow>(v)sem_env \<Rightarrow> 'ffi state \<Rightarrow>(dec)list \<Rightarrow> 'ffi state*(((v)sem_env),(v))result \<Rightarrow> bool "  
      and
evaluate_dec  :: " bool \<Rightarrow>(v)sem_env \<Rightarrow> 'ffi state \<Rightarrow> dec \<Rightarrow> 'ffi state*(((v)sem_env),(v))result \<Rightarrow> bool "  where

"dlet1" : " \<And> ck env p e v1 env' s1 s2 locs.
evaluate ck env s1 e (s2, Rval v1) \<and>
(Lem_list.allDistinct (pat_bindings p []) \<and>
(pmatch(c   env)(refs   s2) p v1 [] = Match env'))
==>
evaluate_dec ck env s1 (Dlet locs p e) (s2, Rval (| v = (alist_to_ns env'), c = nsEmpty |))"

|

"dlet2" : " \<And> ck env p e v1 s1 s2 locs.
evaluate ck env s1 e (s2, Rval v1) \<and>
(Lem_list.allDistinct (pat_bindings p []) \<and>
(pmatch(c   env)(refs   s2) p v1 [] = No_match))
==>
evaluate_dec ck env s1 (Dlet locs p e) (s2, Rerr (Rraise bind_exn_v))"

|

"dlet3" : " \<And> ck env p e v1 s1 s2 locs.
evaluate ck env s1 e (s2, Rval v1) \<and>
(Lem_list.allDistinct (pat_bindings p []) \<and>
(pmatch(c   env)(refs   s2) p v1 [] = Match_type_error))
==>
evaluate_dec ck env s1 (Dlet locs p e) (s2, Rerr (Rabort Rtype_error))"

|

"dlet4" : " \<And> ck env p e s locs.
\<not> (Lem_list.allDistinct (pat_bindings p []))
==>
evaluate_dec ck env s (Dlet locs p e) (s, Rerr (Rabort Rtype_error))"

|

"dlet5" : " \<And> ck env p e err s s' locs.
evaluate ck env s e (s', Rerr err) \<and>
Lem_list.allDistinct (pat_bindings p [])
==>
evaluate_dec ck env s (Dlet locs p e) (s', Rerr err)"

|

"dletrec1" : " \<And> ck env funs s locs.
Lem_list.allDistinct (List.map ( \<lambda>x .  
  (case  x of (x,y,z) => x )) funs)
==>
evaluate_dec ck env s (Dletrec locs funs) (s, Rval (| v = (build_rec_env funs env nsEmpty), c = nsEmpty |))"

|

"dletrec2" : " \<And> ck env funs s locs.
\<not> (Lem_list.allDistinct (List.map ( \<lambda>x .  
  (case  x of (x,y,z) => x )) funs))
==>
evaluate_dec ck env s (Dletrec locs funs) (s, Rerr (Rabort Rtype_error))"

|

"dtype1" : " \<And> ck env tds s locs.
((\<forall> x \<in> (set tds).  check_dup_ctors x))
==>
evaluate_dec ck env s (Dtype locs tds)
    (( s (| next_type_stamp := ((next_type_stamp   s) + List.length tds) |)),
     Rval (| v = nsEmpty, c = (build_tdefs(next_type_stamp   s) tds) |))"

|

"dtype2" : " \<And> ck env tds s locs.
\<not> (((\<forall> x \<in> (set tds).  check_dup_ctors x)))
==>
evaluate_dec ck env s (Dtype locs tds) (s, Rerr (Rabort Rtype_error))"

|

"dtabbrev" : " \<And> ck env tvs tn t0 s locs.

evaluate_dec ck env s (Dtabbrev locs tvs tn t0) (s, Rval (| v = nsEmpty, c = nsEmpty |))"

|

"dexn" : " \<And> ck env cn ts s locs.

evaluate_dec ck env s (Dexn locs cn ts)
    (( s (| next_exn_stamp := ((next_exn_stamp   s) +( 1 :: nat)) |)),
     Rval  (| v = nsEmpty, c = (nsSing cn (List.length ts, ExnStamp(next_exn_stamp   s))) |))"

|

"dmod1" : " \<And> ck s1 s2 env ds mn new_env.
evaluate_decs ck env s1 ds (s2, Rval new_env)
==>
evaluate_dec ck env s1 (Dmod mn ds) (s2, Rval (| v = (nsLift mn(v   new_env)), c = (nsLift mn(c   new_env)) |))"

|

"dmod2" : " \<And> ck s1 s2 env ds mn err.
evaluate_decs ck env s1 ds (s2, Rerr err)
==>
evaluate_dec ck env s1 (Dmod mn ds) (s2, Rerr err)"

|

"empty" : " \<And> ck env s.

evaluate_decs ck env s [] (s, Rval (| v = nsEmpty, c = nsEmpty |))"

|

"cons1" : " \<And> ck s1 s2 env d ds e.
evaluate_dec ck env s1 d (s2, Rerr e)
==>
evaluate_decs ck env s1 (d # ds) (s2, Rerr e)"

|

"cons2" : " \<And> ck s1 s2 s3 env d ds new_env r.
evaluate_dec ck env s1 d (s2, Rval new_env) \<and>
evaluate_decs ck (extend_dec_env new_env env) s2 ds (s3, r)
==>
evaluate_decs ck env s1 (d # ds) (s3, combine_dec_result new_env r)"

\<comment> \<open>\<open>
indreln [evaluate_top : forall 'ffi. bool -> sem_env v -> state 'ffi -> top ->
              state 'ffi * result (sem_env v) v -> bool]

tdec1 : forall ck s1 s2 env d new_env.
evaluate_dec ck env s1 d (s2, Rval new_env)
==>
evaluate_top ck env s1 (Tdec d) (s2, Rval new_env)
and

tdec2 : forall ck s1 s2 env d err.
evaluate_dec ck env s1 d (s2, Rerr err)
==>
evaluate_top ck env s1 (Tdec d) (s2, Rerr err)

and

tmod1 : forall ck s1 s2 env ds mn specs new_env.
evaluate_decs ck env s1 ds (s2, Rval new_env)
==>
evaluate_top ck env s1 (Tmod mn specs ds) (s2, Rval <| v = nsLift mn new_env.v; c = nsLift mn new_env.c |>)

and

tmod2 : forall ck s1 s2 env ds mn specs err.
evaluate_decs ck env s1 ds (s2, Rerr err)
==>
evaluate_top ck env s1 (Tmod mn specs ds) (s2, Rerr err)

indreln [evaluate_prog : forall 'ffi. bool -> sem_env v -> state 'ffi -> prog ->
             state 'ffi * result (sem_env v) v -> bool]

empty : forall ck env s.
true
==>
evaluate_prog ck env s [] (s, Rval <| v = nsEmpty; c = nsEmpty |>)

and

cons1 : forall ck s1 s2 s3 env top tops new_env r.
evaluate_top ck env s1 top (s2, Rval new_env) &&
evaluate_prog ck (extend_dec_env new_env env) s2 tops (s3,r)
==>
evaluate_prog ck env s1 (top::tops) (s3, combine_dec_result new_env r)

and

cons2 : forall ck s1 s2 env top tops err.
evaluate_top ck env s1 top (s2, Rerr err)
==>
evaluate_prog ck env s1 (top::tops) (s2, Rerr err)
\<close>\<close>

inductive
decs_diverges  :: "(v)sem_env \<Rightarrow> 'ffi state \<Rightarrow>(dec)list \<Rightarrow> bool "  
      and
dec_diverges  :: "(v)sem_env \<Rightarrow> 'ffi state \<Rightarrow> dec \<Rightarrow> bool "  where

"dlet" : " \<And> env st locs p e.
Lem_list.allDistinct (pat_bindings p []) \<and> e_diverges env ((refs   st),(ffi   st)) e
==>
dec_diverges env st (Dlet locs p e)"

|

"dmod" : " \<And> st env ds mn.
decs_diverges env st ds
==>
dec_diverges env st (Dmod mn ds)"

|

"cons1" : " \<And> st env d ds.
dec_diverges env st d
==>
decs_diverges env st (d # ds)"

|

"cons2" : " \<And> s1 s2 env d ds new_env.
evaluate_dec False env s1 d (s2, Rval new_env) \<and>
decs_diverges (extend_dec_env new_env env) s2 ds
==>
decs_diverges env s1 (d # ds)"

\<comment> \<open>\<open>
indreln [top_diverges : forall 'ffi. sem_env v -> state 'ffi -> top -> bool]

tdec : forall st env d.
dec_diverges env st d
==>
top_diverges env st (Tdec d)

and

tmod : forall env s1 ds mn specs.
decs_diverges env s1 ds
==>
top_diverges env s1 (Tmod mn specs ds)

indreln [prog_diverges : forall 'ffi. sem_env v -> state 'ffi -> prog -> bool]

cons1 : forall st env top tops.
top_diverges env st top
==>
prog_diverges env st (top::tops)

and

cons2 : forall s1 s2 env top tops new_env.
evaluate_top false env s1 top (s2, Rval new_env) &&
prog_diverges (extend_dec_env new_env env) s2 tops
==>
prog_diverges env s1 (top::tops)
\<close>\<close>
end
