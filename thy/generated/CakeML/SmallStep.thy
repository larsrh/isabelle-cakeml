chapter \<open>Generated by Lem from semantics/alt_semantics/smallStep.lem.\<close>

theory "SmallStep" 

imports 
 	 Main
	 "Lib" 
	 "Namespace" 
	 "Ast" 
	 "Ffi" 
	 "LEM.Lem_pervasives_extra" 
	 "SemanticPrimitives" 

begin 

(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ast*)
(*open import Namespace*)
(*open import SemanticPrimitives*)
(*open import Ffi*)

(* Small-step semantics for expression only.  Modules and definitions have
 * big-step semantics only *)

(* Evaluation contexts
 * The hole is denoted by the unit type
 * The env argument contains bindings for the free variables of expressions in
     the context *)
datatype ctxt_frame =
    Craise " unit "
  | Chandle " unit " " (pat * exp) list "
  | Capp " op0 " " v list " " unit " " exp list "
  | Clog " lop " " unit " " exp "
  | Cif " unit " " exp " " exp "
  (* The value is raised if none of the patterns match *)
  | Cmat " unit " " (pat * exp) list " " v "
  | Clet "  varN option " " unit " " exp "
  (* Evaluating a constructor's arguments
   * The v list should be in reverse order. *)
  | Ccon "  ( (modN, conN)id0)option " " v list " " unit " " exp list "
  | Ctannot " unit " " t "
  | Clannot " unit " " locs "
type_synonym ctxt =" ctxt_frame * v sem_env "

(* State for CEK-style expression evaluation
 * - constructor data
 * - the store
 * - the environment for the free variables of the current expression
 * - the current expression to evaluate, or a value if finished
 * - the context stack (continuation) of what to do once the current expression
 *   is finished.  Each entry has an environment for it's free variables *)

type_synonym 'ffi small_state =" v sem_env * ('ffi, v) store_ffi * exp_or_val * ctxt list "

datatype 'ffi e_step_result =
    Estep " 'ffi small_state "
  | Eabort " abort "
  | Estuck

(* The semantics are deterministic, and presented functionally instead of
 * relationally for proof rather that readability; the steps are very small: we
 * push individual frames onto the context stack instead of finding a redex in a
 * single step *)

(*val push : forall 'ffi. sem_env v -> store_ffi 'ffi v -> exp -> ctxt_frame -> list ctxt -> e_step_result 'ffi*)
definition push  :: "(v)sem_env \<Rightarrow>(v)store*'ffi ffi_state \<Rightarrow> exp \<Rightarrow> ctxt_frame \<Rightarrow>(ctxt_frame*(v)sem_env)list \<Rightarrow> 'ffi e_step_result "  where 
     " push env s e c' cs = ( Estep (env, s, Exp e, ((c',env)# cs)))"


(*val return : forall 'ffi. sem_env v -> store_ffi 'ffi v -> v -> list ctxt -> e_step_result 'ffi*)
definition return  :: "(v)sem_env \<Rightarrow>(v)store*'ffi ffi_state \<Rightarrow> v \<Rightarrow>(ctxt)list \<Rightarrow> 'ffi e_step_result "  where 
     " return env s v1 c1 = ( Estep (env, s, Val v1, c1))"


(*val application : forall 'ffi. op -> sem_env v -> store_ffi 'ffi v -> list v -> list ctxt -> e_step_result 'ffi*)
definition application  :: " op0 \<Rightarrow>(v)sem_env \<Rightarrow>(v)store*'ffi ffi_state \<Rightarrow>(v)list \<Rightarrow>(ctxt)list \<Rightarrow> 'ffi e_step_result "  where 
     " application op1 env s vs c1 = (
  (case  op1 of
      Opapp =>
      (case  do_opapp vs of
          Some (env,e) => Estep (env, s, Exp e, c1)
        | None => Eabort Rtype_error
      )
    | _ =>
      (case  do_app s op1 vs of
          Some (s',r) =>
          (case  r of
              Rerr (Rraise v1) => Estep (env,s',Val v1,((Craise () ,env)# c1))
            | Rerr (Rabort a) => Eabort a
            | Rval v1 => return env s' v1 c1
          )
        | None => Eabort Rtype_error
      )
    ))"


(* apply a context to a value *)
(*val continue : forall 'ffi. store_ffi 'ffi v -> v -> list ctxt -> e_step_result 'ffi*)
fun continue  :: "(v)store*'ffi ffi_state \<Rightarrow> v \<Rightarrow>(ctxt_frame*(v)sem_env)list \<Rightarrow> 'ffi e_step_result "  where 
     " continue s v1 ([]) = ( Estuck )"
|" continue s v1 ((Craise _, env) # c1) = (
        (case  c1 of
            [] => Estuck
          | ((Chandle _ pes,env') # c1) =>
              Estep (env,s,Val v1,((Cmat ()  pes v1, env')# c1))
          | _ # c1 => Estep (env,s,Val v1,((Craise () ,env)# c1))
        ))"
|" continue s v1 ((Chandle _ pes, env) # c1) = (
        return env s v1 c1 )"
|" continue s v1 ((Capp op1 vs _ [], env) # c1) = (
        application op1 env s (v1 # vs) c1 )"
|" continue s v1 ((Capp op1 vs _ (e # es), env) # c1) = (
        push env s e (Capp op1 (v1 # vs) ()  es) c1 )"
|" continue s v1 ((Clog l _ e, env) # c1) = (
        (case  do_log l v1 e of
            Some (Exp e) => Estep (env, s, Exp e, c1)
          | Some (Val v1) => return env s v1 c1
          | None => Eabort Rtype_error
        ))"
|" continue s v1 ((Cif _ e1 e2, env) # c1) = (
        (case  do_if v1 e1 e2 of
            Some e => Estep (env, s, Exp e, c1)
          | None => Eabort Rtype_error
        ))"
|" continue s v1 ((Cmat _ [] err_v, env) # c1) = (
        Estep (env, s, Val err_v, ((Craise () , env) # c1)))"
|" continue s v1 ((Cmat _ ((p,e)# pes) err_v, env) # c1) = (
        if Lem_list.allDistinct (pat_bindings p []) then
          (case  pmatch(c   env) (fst s) p v1 [] of
              Match_type_error => Eabort Rtype_error
            | No_match => Estep (env, s, Val v1, ((Cmat ()  pes err_v,env)# c1))
            | Match env' => Estep (( env (| v := (nsAppend (alist_to_ns env')(v   env)) |)), s, Exp e, c1)
          )
        else
          Eabort Rtype_error )"
|" continue s v1 ((Clet n _ e, env) # c1) = (
        Estep (( env (| v := (nsOptBind n v1(v   env)) |)), s, Exp e, c1))"
|" continue s v1 ((Ccon n vs _ [], env) # c1) = (
        if do_con_check(c   env) n (List.length vs +( 1 :: nat)) then
           (case  build_conv(c   env) n (v1 # vs) of
               None => Eabort Rtype_error
             | Some v1 => return env s v1 c1
           )
        else
          Eabort Rtype_error )"
|" continue s v1 ((Ccon n vs _ (e # es), env) # c1) = (
        if do_con_check(c   env) n (((List.length vs +( 1 :: nat)) +( 1 :: nat)) + List.length es) then
          push env s e (Ccon n (v1 # vs) ()  es) c1
        else
          Eabort Rtype_error )"
|" continue s v1 ((Ctannot _ t, env) # c1) = (
        return env s v1 c1 )"
|" continue s v1 ((Clannot _ l, env) # c1) = (
        return env s v1 c1 )"


(* The single step expression evaluator.  Returns None if there is nothing to
 * do, but no type error.  Returns Type_error on encountering free variables,
 * mis-applied (or non-existent) constructors, and when the wrong kind of value
 * if given to a primitive.  Returns Bind_error when no pattern in a match
 * matches the value.  Otherwise it returns the next state *)

(*val e_step : forall 'ffi. small_state 'ffi -> e_step_result 'ffi*)
fun e_step  :: "(v)sem_env*((v)store*'ffi ffi_state)*exp_or_val*(ctxt)list \<Rightarrow> 'ffi e_step_result "  where 
     " e_step (env, s,(Val v1), c1) = (
        continue s v1 c1 )"
|" e_step (env, s,(Exp e), c1) = (
        (case  e of
            Lit l => return env s (Litv l) c1
          | Raise e =>
              push env s e (Craise () ) c1
          | Handle e pes =>
              push env s e (Chandle ()  pes) c1
          | Con n es =>
              if do_con_check(c   env) n (List.length es) then
                (case  List.rev es of
                    [] =>
                      (case  build_conv(c   env) n [] of
                          None => Eabort Rtype_error
                        | Some v1 => return env s v1 c1
                      )
                  | e # es =>
                      push env s e (Ccon n [] ()  es) c1
                )
              else
                Eabort Rtype_error
          | Var n =>
              (case  nsLookup(v   env) n of
                  None => Eabort Rtype_error
                | Some v1 =>
                    return env s v1 c1
              )
          | Fun n e => return env s (Closure env n e) c1
          | App op1 es =>
              (case  List.rev es of
                  [] => application op1 env s [] c1
                | (e # es) => push env s e (Capp op1 [] ()  es) c1
              )
          | Log l e1 e2 => push env s e1 (Clog l ()  e2) c1
          | If e1 e2 e3 => push env s e1 (Cif ()  e2 e3) c1
          | Mat e pes => push env s e (Cmat ()  pes (Conv (Some ((''Bind''), TypeExn (Short (''Bind'')))) [])) c1
          | Let n e1 e2 => push env s e1 (Clet n ()  e2) c1
          | Letrec funs e =>
              if \<not> (allDistinct (List.map ( \<lambda>x .  
  (case  x of (x,y,z) => x )) funs)) then
                Eabort Rtype_error
              else
                Estep (( env (| v := (build_rec_env funs env(v   env)) |)),
                       s, Exp e, c1)
          | Tannot e t => push env s e (Ctannot ()  t) c1
          | Lannot e l => push env s e (Clannot ()  l) c1
        ))"


(* Define a semantic function using the steps *)

(*val e_step_reln : forall 'ffi. small_state 'ffi -> small_state 'ffi -> bool*)
(*val small_eval : forall 'ffi. sem_env v -> store_ffi 'ffi v -> exp -> list ctxt -> store_ffi 'ffi v * result v v -> bool*)

definition e_step_reln  :: "(v)sem_env*('ffi,(v))store_ffi*exp_or_val*(ctxt)list \<Rightarrow>(v)sem_env*('ffi,(v))store_ffi*exp_or_val*(ctxt)list \<Rightarrow> bool "  where 
     " e_step_reln st1 st2 = (
  (e_step st1 = Estep st2))"


fun 
small_eval  :: "(v)sem_env \<Rightarrow>(v)store*'ffi ffi_state \<Rightarrow> exp \<Rightarrow>(ctxt)list \<Rightarrow>((v)store*'ffi ffi_state)*((v),(v))result \<Rightarrow> bool "  where 
     "
small_eval env s e c1 (s', Rval v1) = ((
  \<exists> env'.  (rtranclp (e_step_reln)) (env,s,Exp e,c1) (env',s',Val v1,[])))"
|"
small_eval env s e c1 (s', Rerr (Rraise v1)) = ((
  \<exists> env'. 
  \<exists> env''.  (rtranclp (e_step_reln)) (env,s,Exp e,c1) (env',s',Val v1,[(Craise () , env'')])))"
|"
small_eval env s e c1 (s', Rerr (Rabort a)) = ((
  \<exists> env'. 
  \<exists> e'. 
  \<exists> c'. 
    (rtranclp (e_step_reln)) (env,s,Exp e,c1) (env',s',e',c') \<and>
    (e_step (env',s',e',c') = Eabort a)))"


(*val e_diverges : forall 'ffi. sem_env v -> store_ffi 'ffi v -> exp -> bool*)
definition e_diverges  :: "(v)sem_env \<Rightarrow>(v)store*'ffi ffi_state \<Rightarrow> exp \<Rightarrow> bool "  where 
     " e_diverges env s e = ((
  \<forall> env'. 
  \<forall> s'. 
  \<forall> e'. 
  \<forall> c'. 
    (rtranclp (e_step_reln)) (env,s,Exp e,[]) (env',s',e',c')
    \<longrightarrow>
((\<exists> env''. \<exists> s''. \<exists> e''. \<exists> c''. 
      e_step_reln (env',s',e',c') (env'',s'',e'',c'')))))"

end
